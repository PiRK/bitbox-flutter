import 'dart:convert';
import 'dart:io';

import 'package:flutter_test/flutter_test.dart';

import 'package:bitbox/bitbox.dart' as Bitbox;

// These tests generate a bunch of keys, addresses and compare them to the testing data generated by the original bitbox
// If there are balances on the addresses, the tests retrieve utxos, compile testing spending transactions,
// and optionally broadcast the transactions
//
// Make sure to run create_test_data.js first to generate the test data.
void main() {
  // path to the file generated by create_test_data.js
  const TEST_DATA_PATH = "/tmp/test_data.json";

  // If these are false, the transactions will be only built and compared to the output generated by bitbox js
  // You can turn these on separately
  const BROADCAST_TESTNET_TRANSACTION = false;
  const BROADCAST_MAINNET_TRANSACTION = false;

  // Data generated by the original bitbox library
  Map testData;

  // Placeholder for data about master, account and childnodes for both networks
  Map nodeData = {"mainnet" : {}, "testnet" : {}};

  // The whole code would be a bit more elegant if this was a map with true/false as keys and forEach would be used
  // in each of the testing methods. However the whole asynchronisity is messed up when it's done that way,
  // so a simple list and for() loop is used
  final networks = ["mainnet", "testnet"];

  // Generate master node master private key and public key and compare with the testing data
  test('Generating master node from mnemonic', () {
    // retrieve and parse the testing data
    final testFile = File.fromUri(Uri(path: TEST_DATA_PATH));
    final testDataJson = testFile.readAsStringSync();
    testData = jsonDecode(testDataJson);

    // create a seed from the mnemonic
    final seed = Bitbox.Mnemonic.toSeed(testData["mnemonic"]);

    // create master nodes for both networks and store their master keys
    for (int i = 0; i < networks.length; i++) {
      final network = networks[i];
      nodeData[network]["master_node"] = Bitbox.HDNode.fromSeed(seed, network == "testnet");
      final masterXPriv = nodeData[network]["master_node"].toXPriv();
      final masterXpub = nodeData[network]["master_node"].toXPub();

      // compare the result with the js test data
      expect(masterXPriv, testData[network]["master_xpriv"]);
      expect(masterXpub, testData[network]["master_xpub"]);
    }
  });

  // generate account node and compare its master keys with the original testing data
  test('Generating account node', () {
    // generate the nodes for both networks
    for (int i = 0; i < networks.length; i++) {
      final network = networks[i];
      nodeData[network]["account_node"] = nodeData[network]["master_node"].derivePath(testData["account_path"]);
      final accountXPriv = nodeData[network]["account_node"].toXPriv();
      final accountXPub = nodeData[network]["account_node"].toXPub();

      // compare the master private and public key with the original testing data
      expect(accountXPriv, testData[network]["account_xpriv"]);
      expect(accountXPub, testData[network]["account_xpub"]);
    }
  });

  // The following few methods work with child nodes of the account node created above.
  // Tests to generate various outputs from each child nodes are separated
  // It is not determined here how many child nodes are created.
  // The test simply follows the index and thus number of child nodes stored in the original test file.
  // That being said, it takes only the index number and derives all other data itself.

  // First generate private keys for each of the child nodes
  test('Generating child nodes and private keys', () {
    // Generate child nodes for each network
    for (int i = 0; i < networks.length; i++) {
      final network = networks[i];

      testData[network]["child_nodes"].forEach((childTestData) {
        // generate the child node and extract its private key
        final childNode = nodeData[network]["account_node"].derive(childTestData["index"]);
        final childPrivateKey = childNode.privateKey;

        // compare the private key with the original test file
        expect(childPrivateKey, childTestData["private_key"]);
      });
    }
  });

  test('Generating child nodes and legacy addresses', () {
    for (int i = 0; i < networks.length; i++) {
      final network = networks[i];
      testData[network]["child_nodes"].forEach((childTestData) {
        final childNode = nodeData[network]["account_node"].derive(childTestData["index"]);
        final childLegacy = childNode.toLegacyAddress();

        expect(childLegacy, childTestData["legacy"]);
      });
    }
  });

  test('Generating child nodes and cash addresses', () {
    for (int i = 0; i < networks.length; i++) {
      final network = networks[i];
      testData[network]["child_nodes"].forEach((childTestData) {
        final childNode = nodeData[network]["account_node"].derive(childTestData["index"]);
        final childCashAddr = childNode.toCashAddress();

        expect(childCashAddr, childTestData["cashAddress"]);
      });
    }
  });

  // For these conversion tests the script uses the addresses from the original script
  test('Converting cashAddr to legacy', () {
    for (int i = 0; i < networks.length; i++) {
      final network = networks[i];
      testData[network]["child_nodes"].forEach((childTestData) {
        final cashAddr = childTestData["cashAddress"];

        expect(Bitbox.Address.toLegacyAddress(cashAddr), childTestData["toLegacy"]);
      });
    }
  });

  test('Converting legacy to cashAddr', () {
    for (int i = 0; i < networks.length; i++) {
      final network = networks[i];
      testData[network]["child_nodes"].forEach((childTestData) {
        final legacy = childTestData["legacy"];

        expect(Bitbox.Address.toCashAddress(legacy), childTestData["toCashAddr"]);
      });
    }
  });

  test('BIP21 test', () {
    final address = 'bitcoincash:qrdsfshx7yzfjl9sfj2khuja5crcu4vaxqrt2qkz5s';

    final options = {
      "amount": 1.0,
      "label": '#BCHForEveryone',
      "message": "There you go"
    };

    final encodedPaymentRequest = "bitcoincash:qrdsfshx7yzfjl9sfj2khuja5crcu4vaxqrt2qkz5s?"
      +"amount=1.0&label=%23BCHForEveryone&message=There%20you%20go";

    expect(Bitbox.BitcoinCash.encodeBIP21(address, options), encodedPaymentRequest);

    final decodedPaymentRequest = Bitbox.BitcoinCash.decodeBIP21(encodedPaymentRequest);

    expect(decodedPaymentRequest["address"], address);
    expect(decodedPaymentRequest["options"]["amount"], options["amount"]);
    expect(decodedPaymentRequest["options"]["label"], options["label"]);
    expect(decodedPaymentRequest["options"]["message"], options["message"]);
  });
}
